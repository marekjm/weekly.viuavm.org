---
layout: post
title:  "Upgrades, fixes, and BASICs"
date:   2017-08-22 21:16:41 +0200
categories: viuavm update weekly
weekly_issue_index: 13
permalink: /issue/13
sections:
    -
        name: Move to Ubuntu Trusty on Travis CI
        id: move-to-ubuntu-trusty-on-travis-ci
    -
        name: Clang 4.x used on Travis CI
        id: clang-4x-used-on-travis-ci
    -
        name: BASIC compiler for Viua VM
        id: basic-compiler-for-viua-vm
    -
        name: Prototype of new static analyzer
        id: prototype-of-new-static-analyzer
    -
        name: Fixed semantics of <code>vinsert</code>'s last operand
        id: fixed-semantics-of-vinserts-last-operand
---

<p>
    Viua has moved to a new release of Ubuntu and Clang for CI,
    a new static analyser is being written, and
    a new language can be used to program the VM.
</p>

<hr>

<section>
    <h1 id="{{ page.sections[0].id }}">{{ page.sections[0].name }}</h1>

    <p>
        Viua VM uses <a href="https://travis-ci.org/">Travis CI</a> for regular (continuous) testing, and
        has moved from the legacy Precise to the "new" Trusty version of the CI environment.
    </p>

    <p>
        On CI Viua is compiled with both GCC and Clang to ensure compatibility with both compilers, and
        exploit the strengths (warnings, static analysis, and sanitisers) of two compilers instead of only one.
        Versions shipped on Trusty by default are a bit old, however, so two PPAs are used to get newer versions
        of the compilers: <a href="https://launchpad.net/~ubuntu-toolchain-r/+archive/ubuntu/test"><code>ubuntu-toolchain-r</code> for GCC</a>, and
        <a href="http://apt.llvm.org/">APT sources for Clang</a> hosted on LLMV.org.
    </p>
</section>

<section>
    <h1 id="{{ page.sections[1].id }}">{{ page.sections[1].name }}</h1>

    <p>
        Viua has been compiled for some time with Clang 4.x already, but on CI it was still being compiled with
        the older 3.9 version.
    </p>

    <p>
        After Travis CI update, Clang's version has also been bumped up.
        The PPA used to install Clang 4.x on Trusty is located <a href="http://apt.llvm.org/">here</a>.
    </p>
</section>

<section>
    <h1 id="{{ page.sections[2].id }}">{{ page.sections[2].name }}</h1>

    <p>
        GitHub user <a href="https://github.com/vktgz">vktgz</a> published a "retro style BASIC dialect" for Viua VM.
        The home page for the compiler is located <a href="http://www.vktgz.rocday.pl/ViuaBasic/">here</a>.
        You are encourages to check out their <a href="http://www.vktgz.rocday.pl/">other projects</a>.
    </p>

{% highlight basic %}
10 PRINT "2.2 * 3.3 = ",2.2*3.3
20 LET A : INTEGER = 0
30 PRINT "Hello ""WORLD"" ! (",A,")"
40 LET A = A + 1
50 GOTO 30
{% endhighlight %}
</section>

<section>
    <h1 id="{{ page.sections[3].id }}">{{ page.sections[3].name }}</h1>

    <p>
        Implementation of a prototype of the new static analyser has begun.
        The old static analyser is <em>very</em> primitive, has several deficiencies, and
        does not understand all of Viua assembly language's features.
    </p>

    <p>
        Most notably, it is not aware of the fact that there are multiple register sets that can be used.
        For example, the following code is obviously incorrect but the current SA will not issue an error for it:
    </p>

    {% highlight lua linenos %}
.function: main/0
    text %1 local "Hello World!"
    print %1 static  -- the error is here: static register 1 is not initialised
                     -- but the program reads value from it

    izero %0 local
    return
.end
    {% endhighlight %}

    <p>
        The reason for this is partially the fact that current static analyser operates on a rather <em>raw</em> view
        of the code: an almost unparsed stream of tokens.
        This is unwieldy, and hard to work with on the level of the SA.
    </p>

    <p>
        The new SA works on a parsed source code, and instead of tokens it sees mnemonics, operands (atoms, labels,
        register indexes, etc.), functions, directives, etc.
        This representation is much easier to work with, and allows the SA to "see" more.
    </p>

    <p>
        Parsed elements track their own location so error traces generated by the new SA are more detailed than the old ones.
        The traces are longer as the result of additional details being included, but this lets the SA better explain how
        it determined that a particular instruction would result in an error at runtime.
    </p>
</section>

<section>
    <h1 id="{{ page.sections[4].id }}">{{ page.sections[4].name }}</h1>

    <p>
        The GitHub user <a href="https://github.com/vktgz">vktgz</a>, apart from implementing a BASIC compiler, has also found
        a bug in the way <code><a href="https://docs.viuavm.org/isa/vinsert.html">vinsert</a></code> instruction handled its last
        operand.
    </p>

    <p>
        Viua has several register access modes (i.e. ways to access values stored in registers): <em>plain</em>,
        <em>pointer-dereference</em>, and <em>register-indirect</em>; each with different semantics.
        There are also literal values used by constructor instructions (instructions that create completely new values, instead of
        producing new values based on some other values; <code><a href="https://docs.viuavm.org/isa/istore.html">istore</a></code>
        is a constructor instruction, but <code><a href="https://docs.viuavm.org/isa/add.html">add</a></code> is not).
    </p>

    <p>
        The essence of the bug was that <em>plain</em>, <em>register-indirect</em> and literal value modes were mixed up.
        The <a href="https://github.com/marekjm/viuavm/issues/182">issue</a> for the bug has already been closed.
    </p>
</section>
